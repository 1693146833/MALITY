import{j as t,c as o,R as c}from"./client-UEgrHnC1.js";const i={id:2,name:"算法简介",cardList:[{front:"广度优先搜索（BFS）：",back:"广度优先搜索是一种用于遍历或搜索树或图数据结构的算法。它在移动到下一层之前探索当前深度的所有相邻节点。BFS 通常使用队列数据结构实现。",hint:"BFS",tag:["算法"],progress:0,timestamp:0},{front:"深度优先搜索（DFS）：",back:"深度优先搜索是一种用于遍历或搜索树或图数据结构的算法。它首先探索当前节点的所有子节点，然后再依次探索每个子节点的子节点。DFS 通常使用递归实现。",hint:"DFS",tag:["算法"],progress:0,timestamp:0},{front:"动态规划（Dynamic Programming）：",back:"动态规划是一种用于解决复杂问题的方法，它将问题分解为更简单的子问题，并且每个子问题的解只计算一次，然后将其存储起来，以便以后使用。",hint:"动态规划",tag:["算法"],progress:0,timestamp:0},{front:"贪心算法（Greedy Algorithm）：",back:"贪心算法是一种解决问题的策略，它每次都选择当前最优解，而不考虑未来的后果。尽管贪心算法通常不能保证找到全局最优解，但它们通常可以在实践中得到一个接近最优解的解。",hint:"贪心算法",tag:["算法"],progress:0,timestamp:0},{front:"二分查找（Binary Search）：",back:"二分查找是一种在有序数组中查找特定元素的算法。它将数组中间的元素与目标值进行比较，并根据比较结果来确定继续搜索的方向。",hint:"二分查找",tag:["算法"],progress:0,timestamp:0},{front:"递归（Recursion）：",back:"递归是一种在函数内部调用自身的过程。它通常用于解决可以被分解为相同类型的更小问题的问题。",hint:"递归",tag:["编程"],progress:0,timestamp:0},{front:"栈（Stack）：",back:"栈是一种数据结构，它遵循后进先出（LIFO）原则。栈通常具有两个基本操作：推入（将元素添加到栈顶）和弹出（将栈顶元素移除）。",hint:"栈",tag:["数据结构"],progress:0,timestamp:0},{front:"队列（Queue）：",back:"队列是一种数据结构，它遵循先进先出（FIFO）原则。队列通常具有两个基本操作：入队（将元素添加到队尾）和出队（将队首元素移除）。",hint:"队列",tag:["数据结构"],progress:0,timestamp:0},{front:"哈希表（Hash Table）：",back:"哈希表是一种数据结构，它使用哈希函数将键映射到存储桶中的位置。哈希表通常用于快速查找，插入和删除操作。",hint:"哈希表",tag:["数据结构"],progress:0,timestamp:0},{front:"链表（Linked List）：",back:"链表是一种数据结构，它由节点组成，每个节点包含一个数据元素和一个指向下一个节点的指针。链表通常用于实现其他数据结构，如堆栈和队列。",hint:"链表",tag:["数据结构"],progress:0,timestamp:0}]};function l(){const s=new URLSearchParams(window.location.search).get("id");let a=JSON.parse(sessionStorage.getItem("resourceData"));console.log(a,"data"),a=a.find(r=>r.id==s),console.log(s,"id"),s=="1"&&(a={src:{original:"./src/assets/3.jpg"},alt:"1",photographer:"1",photographer_url:"https://www.pexels.com/@pixabay"});const e=i.cardList;function n(){const r=JSON.parse(localStorage.getItem("CardGroupData"));if(r==null){localStorage.setItem("CardGroupData",JSON.stringify([i]));return}r.push(i),localStorage.setItem("CardGroupData",JSON.stringify(r))}return t.jsxs(t.Fragment,{children:[t.jsxs("h2",{style:{color:"lightgray",fontSize:"0.3rem"},children:["Explore ",s]}),t.jsxs("div",{className:"container",style:{display:"flex"},children:[t.jsxs("section",{className:"detail-content",children:[t.jsx("img",{className:"detail-image",src:a.src.original,alt:a.alt}),t.jsxs("p",{className:"detail-photographer",children:[t.jsx("span",{children:"Photographer:"}),t.jsx("a",{href:a.photographer_url,children:a.photographer})]})]}),t.jsxs("section",{className:"detail-description",children:[t.jsxs("aside",{children:[t.jsx("h4",{children:i.name}),t.jsx("p",{children:"本卡组介绍了广度优先搜索（BFS）算法，该算法用于遍历或搜索树或图数据结构。它在移动到下一层级之前，会先探索当前深度的所有相邻节点。BFS通常使用队列数据结构来实现。"}),t.jsx("p",{children:"卡组试读"}),t.jsxs("ul",{children:[t.jsx("li",{children:e[0].front}),t.jsx("li",{children:e[0].back}),t.jsx("li",{children:e[1].front}),t.jsx("li",{children:e[1].back}),t.jsx("li",{children:e[2].front}),t.jsx("li",{children:e[2].back})]})]}),t.jsxs("div",{style:{display:"flex",gap:"1rem"},children:[t.jsx("button",{className:"back-button",onClick:()=>window.history.back(),children:"返回"}),t.jsx("button",{className:"add-button",onClick:n,children:"添加此卡组"})]})]})]})]})}o.createRoot(document.getElementById("root")).render(t.jsx(c.StrictMode,{children:t.jsx(l,{})}));
